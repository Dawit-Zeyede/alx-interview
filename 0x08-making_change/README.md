I worked on the Coin Change Problem, a classic algorithmic challenge that involves finding the minimum number of coins needed to make up a given total using a specified set of coin denominations. This project allowed me to explore both dynamic programming and greedy algorithms, focusing on choosing the most suitable approach for the problem's constraints. My program takes a list of coin denominations and a target amount (total) as inputs, returning the fewest coins required to reach the total or -1 if it is impossible. The implementation ensures correctness while handling edge cases, such as when the total is 0 or when no combination of coins can meet the total.

To validate my solution, I used the 0-main.py file with test cases. For example, with denominations [1, 2, 25] and a target of 37, the program correctly returned 7 coins. In another test, where no combination of coins could meet a total of 1453, the program returned -1, confirming its reliability. My code follows PEP 8 style guidelines (version 1.7.x) and runs on Ubuntu 20.04 LTS using Python 3.4.3. The project reinforced my understanding of optimization algorithms while teaching me how to design efficient and reusable solutions. This experience was both challenging and rewarding, as it highlighted the importance of balancing correctness and efficiency in algorithmic problem-solving.
